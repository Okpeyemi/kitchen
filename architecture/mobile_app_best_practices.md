# Architecture & Best Practices for Mobile App Development (Expo/React Native)

This document outlines the recommended architecture and best practices for building scalable, maintainable, and high-performance mobile applications using Expo.

## 1. Directory Structure

A clean and intuitive directory structure is crucial. We recommend a feature-based or domain-based grouping alongside common utilities.

```
/
├── app/                  # Expo Router file-based routing
│   ├── (auth)/           # Authentication group (login, signup)
│   ├── (tabs)/           # Main tab navigation
│   ├── _layout.tsx       # Root layout & providers
│   └── index.tsx         # Entry point
├── components/           # Reusable UI components
│   ├── ui/               # Primitive components (Button, Input, Card)
│   └── [Feature]/        # Feature-specific components
├── constants/            # Global constants (Colors, Fonts, Config)
├── hooks/                # Custom React hooks
├── services/             # API calls and external services
├── store/                # State management (Zustand, Redux, Context)
├── types/                # TypeScript definitions
├── utils/                # Helper functions
└── assets/               # Images, fonts, etc.
```

## 2. Component Architecture

### Atomic Design Principles
- **Atoms**: Basic building blocks (Buttons, Inputs, Typos).
- **Molecules**: Groups of atoms (SearchField, UserCard).
- **Organisms**: Complex sections (Header, ProductList).
- **Templates/Pages**: Full screen layouts.

### Best Practices
- **Functional Components**: Use functional components with Hooks.
- **Props Interface**: Always define a TypeScript interface for props.
- **Micro-components**: Break down large components into smaller chunks.

Example of a reusable Button component:
```tsx
import { Colors } from '@/constants/Theme';
import { Text, TouchableOpacity, StyleSheet } from 'react-native';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
}

export const Button = ({ title, onPress, variant = 'primary' }: ButtonProps) => {
  return (
    <TouchableOpacity 
      style={[styles.container, variant === 'secondary' && styles.secondary]} 
      onPress={onPress}
    >
      <Text style={[styles.text, variant === 'secondary' && styles.textSecondary]}>
        {title}
      </Text>
    </TouchableOpacity>
  );
};
// ... styles
```

## 3. Styling Theme

Avoid hardcoding colors or magic numbers. Use a centralized theme system.

- **Colors**: Define a palette in `constants/Theme.ts`.
- **Typography**: Define font families and sizes constants.
- **Spacing**: Use consistent spacing units (4, 8, 16, 24px...).

## 4. State Management

- **Local State**: Use `useState` for component-level state.
- **Global State**: Use `Zustand` or `React Context` for app-wide state (User, Theme, shopping cart).
- **Server State**: Use `React Query` (TanStack Query) for API data caching and synchronization.

## 5. Performance Optimization

- **Lists**: Always use `FlashList` (Shopify) or optimized `FlatList` for long lists.
- **Memoization**: Use `useMemo` and `useCallback` for expensive calculations or to prevent re-renders in children.
- **Images**: Use `expo-image` for caching and performance.

## 6. Navigation (Expo Router)

Expo Router brings the web-like file-system routing to native.
- **_layout.tsx**: Define stacks and tabs here.
- **Typed Routes**: Use `experiments: { typedRoutes: true }` in `app.json`.
- **Groups**: Use `(group)` to organize routes logically without affecting the URL structure.

## 7. Icons & Assets

- Use vector icons (Heroicons, Ionicons) via libraries like `react-native-heroicons` or `@expo/vector-icons`.
- Optimize images before adding to assets.
- Preload fonts and images in `_layout.tsx`.


## 8. Development Workflow

- **Linting & Formatting**: Use ESLint and Prettier.
- **Typescript**: Strict mode enabled.
- **Pre-commit hooks**: Ensure quality before pushing (Husky).

---
*Generated by Antigravity*
